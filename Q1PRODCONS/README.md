# Problem 1: Producer-Consumer Problem

## Question

```text
--------------- PRODCONS (subfolder 1)
-------------- README file with directions (make sure to include actual commands that can be copied and pasted to run)
-------------- SOURCE code (well documented)
-------------- Executable code
-------------- Sample input data files
-------------- Sample output file(s)
----------------A report that summarizes your findings from the experiments
Here, we have a set of p producers and c consumers, each running as a single thread.
They are synchronized via shared buffer of size b (i.e., it can accommodate b items).
Each buffer item contains the following information: Sales Date (DD/MM/YY), store ID
(integer), register# (integer), sale amount (float). Each item represents a sales record from
a specific cashier register in a particular location of a retail-chain. Thus, each producer
reports sales from a specific store location. Each consumer represents an entity that reads
sales records and computes sales statistics locally. Each buffer item is consumed by oneand-only-one consumer. When all sales records have been read (indicated by a special
flag set by another designated thread), each consumer adds its local statistics to the global
statistics (in the shred space). It also prints its own local statistics along with its ID. In
addition, your main program (parent process) prints the overall (global) statistics.
The statistics to be maintained are:
Store-wide total sales
Month-wise total sales (in all stores)
Aggregate sales (all sales together)
Total time for simulation (from begin to end)
Each producer produces records randomly. Assume that the DD field is 1-30, MM is 01-
12, and YY is always 16. Store IDs are in the 1 to p range (where p is the number of
producers). The register numbers range from 1-6 for any store. The sale amount in each
item can range between 0.50 and 999.99. Each producer generates its record with random
data. Run the program until 1000 items are produced by all producers together.
Obviously, the number of items produced so far (by all producers) need to be maintained
in shared memory. Each producer is assigned a fixed store ID when it is created. It has
the following structure:
While the total number of items generated by all producers is less than 1000
do
{
 Randomly generate DD, MM, register#, sale amount.
 Create a sales record and place it in the shared buffer.
 Increment the number of records count (in the shared memory)
 Randomly sleep for 5-40 milliseconds
}
Your report should clearly indicate the places where shared variables and semaphores
were employed by your code to manage shared variables. Run your program for p=2, 5,
and 10 (i.e., try all three possible values for number of producers). Similarly, run it for
c=2, 5, and 10, and b= 3 and 10. So there will be 18 runs in total. Your report should
compile the results from all 9 runs and make a comparison of the time. Use pseudo
random number generators to generate data. 
Your report must show a summary of runs and your conclusions.
```

## Answer

### Main.cpp

#### 1. Introduction

**Objective**:  
To implement a multithreaded producer-consumer system synchronized via a shared buffer, where producers generate sales records, and consumers compute and aggregate statistics. The program simulates varying configurations of producers (`p`), consumers (`c`), and buffer sizes (`b`) to analyze performance.

**Scope**:  
This report:

1. Details shared variables and synchronization mechanisms used.
2. Analyzes performance data collected across 18 simulation runs.
3. Provides insights and recommendations for scalability and optimization.

---

#### 2. Shared Variables and Synchronization

##### Shared Variables

| **Variable**       | **Purpose**                                                                                   |
|---------------------|-----------------------------------------------------------------------------------------------|
| `totalRecords`      | Tracks the total number of records produced (atomic).                                         |
| `globalSales`       | Stores the total aggregate sales across all stores and months.                                |
| `storeSales`        | Map of store IDs to their total sales.                                                        |
| `monthSales`        | Map of month numbers to their total sales across stores.                                      |
| `done`              | Boolean flag to indicate when all producers have completed their tasks (atomic).              |

##### Synchronization Mechanisms

| **Mechanism**           | **Usage**                                                                                 |
|--------------------------|-------------------------------------------------------------------------------------------|
| `std::mutex`             | Ensures thread-safe access to shared variables (`globalSales`, `storeSales`, `monthSales`).|
| `std::condition_variable`| Synchronizes producers and consumers:                                                    |
|                          | - `cvFull`: Signals producers when the buffer has space.                                 |
|                          | - `cvEmpty`: Signals consumers when the buffer has data.                                 |

**Key Points**:

- Producers and consumers share access to the buffer, protected by condition variables.
- Statistics are updated using a mutex to avoid race conditions.

---

##### 3. Simulation Results

##### Configurations Tested

- **Buffer Sizes (`b`)**: 3, 10
- **Producers (`p`)**: 2, 5, 10
- **Consumers (`c`)**: 2, 5, 10
- Total combinations: 18 (3 × 3 × 2)

##### Timing Results

The following table shows the time taken (in seconds) for each configuration of buffer size (`b`), producers (`p`), and consumers (`c`):

| Buffer Size (b) | Producers (p) | Consumers (c) | Time (seconds) |
|------------------|---------------|---------------|----------------|
| 3                | 2             | 2             | 30.943         |
| 3                | 2             | 5             | 31.1081        |
| 3                | 2             | 10            | 30.9365        |
| 3                | 5             | 2             | 77.1477        |
| 3                | 5             | 5             | 30.8725        |
| 3                | 5             | 10            | 31.1241        |
| 3                | 10            | 2             | 153.336        |
| 3                | 10            | 5             | 61.3629        |
| 3                | 10            | 10            | 30.8975        |
| 10               | 2             | 2             | 31.008         |
| 10               | 2             | 5             | 31.1123        |
| 10               | 2             | 10            | 30.9527        |
| 10               | 5             | 2             | 76.6941        |
| 10               | 5             | 5             | 30.9712        |
| 10               | 5             | 10            | 30.9936        |
| 10               | 10            | 2             | 153.454        |
| 10               | 10            | 5             | 61.624         |
| 10               | 10            | 10            | 31.0578        |

##### Performance Trends

1. **Impact of Increasing Producers**:
   - Increasing producers (`p`) reduces the time producers spend waiting for buffer space but increases contention for shared resources.
   - At higher `p` values, the buffer fills up faster, leading to potential bottlenecks in consumers.

2. **Impact of Increasing Consumers**:
   - Increasing consumers (`c`) speeds up consumption, but more threads compete for buffer access and shared statistics.

3. **Impact of Buffer Size**:
   - A larger buffer size (`b = 10`) reduces contention and allows producers to work more efficiently.
   - A smaller buffer size (`b = 3`) increases synchronization overhead as producers and consumers frequently block.

---

#### 4. Insights and Scalability

##### Key Insights

1. **Buffer Size Matters**:
   - A larger buffer significantly improves throughput by reducing producer-consumer contention.
   - However, excessively large buffers may increase memory usage and reduce responsiveness.

2. **Optimal Configuration**:
   - Based on the results, configurations with balanced producers and consumers (e.g., `p=5, c=5, b=10`) performed best.

3. **Bottlenecks**:
   - At high `p` and low `b`, producers frequently block, causing idle threads.
   - At high `c`, consumers contend for shared statistics, creating potential overhead.

##### Scalability Recommendations

- **Thread Pooling**:
  - Use a thread pool to limit the number of active threads and reduce overhead from thread creation.
- **Lock-Free Data Structures**:
  - Consider using lock-free queues for the buffer to reduce mutex contention.
- **Dynamic Buffer Management**:
  - Adapt buffer size dynamically based on workload to optimize resource usage.

---

#### 5. Conclusion

This project demonstrated the implementation of a producer-consumer system with shared memory and synchronization. The results highlight the importance of balancing producers, consumers, and buffer size for optimal performance. Future improvements could explore advanced synchronization techniques and dynamic resource management.

---

---

## 1. Impact of Increasing Producers

### Observation:

- **Small Buffer Size (`b = 3`)**:
  - Low consumer counts (`c=2`) lead to significantly higher times when producer counts (`p`) increase:
    - `p=2, c=2`: 30.943s
    - `p=5, c=2`: 77.1477s
    - `p=10, c=2`: 153.336s
  - Increasing consumer counts stabilizes the times:
    - `p=10, c=10`: 30.8975s.

- **Large Buffer Size (`b = 10`)**:
  - Larger buffers reduce contention slightly for higher producer counts but follow similar trends:
    - `p=2, c=2`: 31.008s
    - `p=5, c=2`: 76.6941s
    - `p=10, c=2`: 153.454s
  - High consumer counts (`c=10`) help maintain stable times:
    - `p=10, c=10`: 31.0578s.

### Explanation:

- When the number of producers increases, the buffer fills up faster, causing contention between producers and consumers.
- Increasing consumer counts reduces this contention, allowing more stable times.
- A larger buffer slightly mitigates delays but cannot overcome the bottleneck of too few consumers.

---

## 2. Impact of Increasing Consumers

### Observation:

- **Small Buffer Size (`b = 3`)**:
  - More consumers (`c`) significantly stabilize times:
    - `p=2, c=2`: 30.943s
    - `p=2, c=10`: 30.9365s.
    - `p=5, c=2`: 77.1477s → `p=5, c=10`: 31.1241s.
    - `p=10, c=2`: 153.336s → `p=10, c=10`: 30.8975s.

- **Large Buffer Size (`b = 10`)**:
  - Similar stabilization observed:
    - `p=10, c=2`: 153.454s → `p=10, c=10`: 31.0578s.

### Explanation:

- More consumers allow faster emptying of the buffer, reducing delays for producers.
- This leads to stable performance even with higher producer counts.

---

## 3. Impact of Buffer Size

### Observation:

- **Few Producers (`p=2`)**:
  - Buffer size has minimal impact as contention is low:
    - `b=3, c=2`: 30.943s → `b=10, c=2`: 31.008s.

- **Many Producers (`p=10`)**:
  - Larger buffers reduce contention slightly:
    - `b=3, c=5`: 61.3629s → `b=10, c=5`: 61.624s.
    - `b=3, c=10`: 30.8975s → `b=10, c=10`: 31.0578s.

### Explanation:

- Larger buffers help reduce contention when producer counts are high, especially with moderate consumer counts.
- However, with sufficient consumers (`c=10`), buffer size has less impact as processing is balanced.

---

## 4. Insights and Recommendations

### Key Insights

1. **Buffer Size**:
   - A small buffer (`b=3`) causes delays when there are too many producers (`p=10`) and not enough consumers (`c=2`).
   - A larger buffer helps reduce delays, but it doesn’t fix the problem completely if there aren’t enough consumers.

2. **Balancing Producers and Consumers**:
   - Having too many producers and too few consumers creates a bottleneck.
   - Having too many consumers adds unnecessary overhead when there aren’t enough producers.

3. **Best Setup**:
   - Balanced setups like `p=5, c=5, b=10` work well for most workloads.
   - Adding more consumers (`c=10`) is the best way to keep the system fast, even with many producers.

---

### Recommendations

1. **Dynamic Buffer Size**:
   - Adjust the buffer size based on how many producers and consumers are running. This can help balance the workload.

2. **Use a Thread Pool**:
   - Limit the number of active threads by using a thread pool. This will reduce delays caused by too many threads competing for resources.

3. **Dynamic Adjustments**:
   - Automatically change the number of producers or consumers depending on how much work needs to be done.

---

### Compile, Execute, & Output

If you wish to compile question one from this directory run the command

`g++ src\main.cpp -o executable\main`

The executable will the be located in the [executable](/Q1PRODCONS/executable/) directory, you can then run the executable wiith the following commands:

Linux:

`./executable/main.exe`

Windows:

`.\executable\main.exe`

The output will be located in the [output](/Q1PRODCONS/output/results.txt) file and the `console`

### Executable Directory

[executable](/Q1PRODCONS/executable)

### Source Directory

[src](/Q1PRODCONS/src)

### Input Directory

[input](/Q1PRODCONS/input)

### Output Directory

[output](/Q1PRODCONS/output)
